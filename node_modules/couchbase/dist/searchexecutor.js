"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchExecutor = void 0;
/* eslint jsdoc/require-jsdoc: off */
const bindingutilities_1 = require("./bindingutilities");
const searchtypes_1 = require("./searchtypes");
const streamablepromises_1 = require("./streamablepromises");
/**
 * @internal
 */
class SearchExecutor {
    /**
     * @internal
     */
    constructor(cluster) {
        this._cluster = cluster;
    }
    /**
     * @internal
     */
    query(indexName, query, options) {
        const emitter = new streamablepromises_1.StreamableRowPromise((rows, meta) => {
            return new searchtypes_1.SearchResult({
                rows: rows,
                meta: meta,
            });
        });
        const timeout = options.timeout || this._cluster.searchTimeout;
        this._cluster.conn.search({
            timeout,
            index_name: indexName,
            query: JSON.stringify(query),
            limit: options.limit,
            skip: options.skip,
            explain: options.explain || false,
            disable_scoring: options.disableScoring || false,
            include_locations: options.includeLocations || false,
            highlight_style: options.highlight
                ? (0, bindingutilities_1.searchHighlightStyleToCpp)(options.highlight.style)
                : undefined,
            highlight_fields: options.highlight && options.highlight.fields
                ? options.highlight.fields
                : [],
            fields: options.fields || [],
            collections: options.collections || [],
            scan_consistency: (0, bindingutilities_1.searchScanConsistencyToCpp)(options.consistency),
            mutation_state: (0, bindingutilities_1.mutationStateToCpp)(options.consistentWith),
            sort_specs: options.sort
                ? options.sort.map((sort) => JSON.stringify(sort))
                : [],
            facets: options.facets
                ? Object.fromEntries(Object.entries(options.facets).map(([k, v]) => [
                    k,
                    JSON.stringify(v),
                ]))
                : {},
            raw: options.raw
                ? Object.fromEntries(Object.entries(options.raw).map(([k, v]) => [
                    k,
                    JSON.stringify(v),
                ]))
                : {},
            body_str: '',
        }, (cppErr, resp) => {
            const err = (0, bindingutilities_1.errorFromCpp)(cppErr);
            if (err) {
                emitter.emit('error', err);
                emitter.emit('end');
                return;
            }
            resp.rows.forEach((row) => {
                emitter.emit('row', row);
            });
            {
                const metaData = resp.meta;
                emitter.emit('meta', metaData);
            }
            emitter.emit('end');
            return;
        });
        return emitter;
    }
}
exports.SearchExecutor = SearchExecutor;
